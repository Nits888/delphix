import os
import logging
from flask import Flask, request, jsonify
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
import psycopg2
from psycopg2 import pool
import json
from cryptography.fernet import Fernet
from waitress import serve

app = Flask(__name__)

# Set the maximum secret size limit to 512 KB (512 * 1024 bytes)
app.config['MAX_CONTENT_LENGTH'] = 512 * 1024

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Database configuration
DATABASE_CONFIG = {
    'host': 'your_database_host',
    'database': 'your_database_name',
    'user': 'your_database_user',
    'password': 'your_database_password',
}

# Database connection pool configuration
MIN_CONNECTIONS = 4
MAX_CONNECTIONS = 10

# Create the database connection pool
connection_pool = psycopg2.pool.ThreadedConnectionPool(
    minconn=MIN_CONNECTIONS,
    maxconn=MAX_CONNECTIONS,
    **DATABASE_CONFIG
)

# File path to store the encryption key
ENCRYPTION_KEY_FILE_PATH = 'encryption_key.key'

# File path for the JSON configuration file
CONFIG_FILE_PATH = 'config.json'

# Function to load the JSON configuration file
def load_config():
    with open(CONFIG_FILE_PATH, 'r') as config_file:
        config = json.load(config_file)
    return config

# Function to check if hostname and process name are whitelisted
def is_whitelisted(hostname, process_name, config):
    whitelist = config.get('whitelist', [])
    for entry in whitelist:
        if entry.get('hostname') == hostname and entry.get('process_name') == process_name:
            return True
    return False

# Function to generate or load the encryption key
def get_encryption_key():
    if os.path.exists(ENCRYPTION_KEY_FILE_PATH):
        with open(ENCRYPTION_KEY_FILE_PATH, 'rb') as key_file:
            key = key_file.read()
    else:
        key = Fernet.generate_key()
        with open(ENCRYPTION_KEY_FILE_PATH, 'wb') as key_file:
            key_file.write(key)
    return key

# Encryption key (load the key from file system)
ENCRYPTION_KEY = get_encryption_key()

# Function to initialize secrets by fetching them from the database
def initialize_secrets():
    try:
        config = load_config()
        if config:
            secrets = fetch_secrets_from_database()
            for secret in secrets:
                secret_id = secret['id']
                hostname = secret['hostname']
                process_name = secret['process_name']
                secret_value = secret['secret_value']

                # Check if hostname and process name are whitelisted
                if is_whitelisted(hostname, process_name, config):
                    # Decrypt the secret value
                    decrypted_secret = decrypt_secret(secret_value, ENCRYPTION_KEY)

                    # Create a JSON file for each secret
                    file_path = os.path.join('secrets', f'secret_{secret_id}.json')
                    with open(file_path, 'w') as json_file:
                        json.dump({'secret': decrypted_secret}, json_file)

                    logging.info(f'Secret {secret_id} initialized.')

    except Exception as e:
        logging.error("Error initializing secrets: %s", e)

# Function to fetch secrets from the database
def fetch_secrets_from_database():
    try:
        with connection_pool.getconn() as conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT id, hostname, process_name, secret_value FROM secrets;")
                secrets = cursor.fetchall()
        return secrets
    except Exception as e:
        logging.error("Error fetching secrets from the database: %s", e)
        return []

# Function to encrypt a secret using the encryption key
def encrypt_secret(secret, encryption_key):
    cipher_suite = Fernet(encryption_key)
    encrypted_secret = cipher_suite.encrypt(secret.encode('utf-8'))
    return encrypted_secret

# Function to decrypt a secret using the encryption key
def decrypt_secret(encrypted_secret, encryption_key):
    cipher_suite = Fernet(encryption_key)
    decrypted_secret = cipher_suite.decrypt(encrypted_secret)
    return decrypted_secret.decode('utf-8')

# Function to store a secret in the database
def store_secret_in_database(hostname, process_name, encrypted_secret):
    try:
        with connection_pool.getconn() as conn:
            with conn.cursor() as cursor:
                cursor.execute(
                    "INSERT INTO secrets (hostname, process_name, secret_value) VALUES (%s, %s, %s);",
                    (hostname, process_name, encrypted_secret)
                )
                conn.commit()
        return True
    except Exception as e:
        logging.error("Error storing secret in the database: %s", e)
        return False

# Function to update a secret in the database
def update_secret_in_database(secret_id, encrypted_secret):
    try:
        with connection_pool.getconn() as conn:
            with conn.cursor() as cursor:
                cursor.execute(
                    "UPDATE secrets SET secret_value = %s WHERE id = %s;",
                    (encrypted_secret, secret_id)
                )
                conn.commit()
        return True
    except Exception as e:
        logging.error("Error updating secret in the database: %s", e)
        return False

# Function to delete a secret from the database
def delete_secret_from_database(secret_id):
    try:
        with connection_pool.getconn() as conn:
            with conn.cursor() as cursor:
                cursor.execute(
                    "DELETE FROM secrets WHERE id = %s;",
                    (secret_id,)
                )
                conn.commit()
        return True
    except Exception as e:
        logging.error("Error deleting secret from the database: %s", e)
        return False

# REST endpoints for CRUD operations
@app.route('/secrets', methods=['GET'])
@limiter.limit("10 per minute")
def get_all_secrets():
    try:
        secrets = fetch_secrets_from_database()
        return jsonify(secrets)
    except Exception as e:
        logging.error("Error fetching all secrets: %s", e)
        return jsonify(error="Error fetching secrets"), 500

@app.route('/secrets/<int:secret_id>', methods=['GET'])
@limiter.limit("20 per minute")
def get_secret(secret_id):
    try:
        with connection_pool.getconn() as conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT id, hostname, process_name, secret_value FROM secrets WHERE id = %s;", (secret_id,))
                secret = cursor.fetchone()
        if secret:
            return jsonify(secret)
        else:
            return jsonify(error="Secret not found"), 404
    except Exception as e:
        logging.error("Error fetching secret: %s", e)
        return jsonify(error="Error fetching secret"), 500

@app.route('/secrets', methods=['POST'])
@limiter.limit("5 per minute")
def create_secret():
    try:
        data = request.get_json()
        hostname = data.get('hostname')
        process_name = data.get('process_name')
        secret_value = data.get('secret_value')

        # Encrypt the secret value
        encrypted_secret = encrypt_secret(secret_value, ENCRYPTION_KEY)

        if store_secret_in_database(hostname, process_name, encrypted_secret):
            return jsonify(message="Secret created successfully")
        else:
            return jsonify(error="Failed to create secret"), 500
    except Exception as e:
        logging.error("Error creating secret: %s", e)
        return jsonify(error="Error creating secret"), 500

@app.route('/secrets/<int:secret_id>', methods=['PUT'])
@limiter.limit("5 per minute")
def update_secret(secret_id):
    try:
        data = request.get_json()
        secret_value = data.get('secret_value')

        # Encrypt the secret value
        encrypted_secret = encrypt_secret(secret_value, ENCRYPTION_KEY)

        if update_secret_in_database(secret_id, encrypted_secret):
            return jsonify(message="Secret updated successfully")
        else:
            return jsonify(error="Failed to update secret"), 500
    except Exception as e:
        logging.error("Error updating secret: %s", e)
        return jsonify(error="Error updating secret"), 500

@app.route('/secrets/<int:secret_id>', methods=['DELETE'])
@limiter.limit("2 per minute")
def delete_secret(secret_id):
    try:
        if delete_secret_from_database(secret_id):
            return jsonify(message="Secret deleted successfully")
        else:
            return jsonify(error="Failed to delete secret"), 500
    except Exception as e:
        logging.error("Error deleting secret: %s", e)
        return jsonify(error="Error deleting secret"), 500

if __name__ == '__main__':
    try:
        # Fetch secrets from the database and generate JSON files upon startup
        initialize_secrets()

        # Load JSON configuration file
        config = load_config()

        # Use Waitress to serve the Flask app
        serve(app, host='0.0.0.0', port=8000)
    except Exception as e:
        logging.error("An error occurred: %s", e)
    finally:
        # Close the database connection pool on exit
        connection_pool.closeall()
        logging.info("Database connections closed.")
